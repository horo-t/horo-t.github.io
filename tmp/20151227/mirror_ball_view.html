<html>
<head>
<title>Mirror ball view</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style>
body {
  background-color: #000000;
  margin: 0px;
  overflow: hidden;
}
#container {
  position: absolute;
  padding: 0;
  border: 0;
  margin: 0;
  top: 40px;
}
body {
  background-color: #000000;
  margin: 0px;
  overflow: hidden;
}
#container {
  position: absolute;
  top: 40px;
  padding: 0;
  border: 0;
  margin: 0;
}
#menu {
    outline: none;
    position: absolute;
    top:0px;
    width: 100%;
    height: 40px;
    left: 0px;
    padding: 0;
    border: 0;
    margin: 0;
    background-color: #eee;
}
.button {
    outline: none;
    position: absolute;
    top: 0;
    width: 24px;
    height: 24px;
    padding: 0;
    border: 0;
    margin: 8px;
    background-size: 100%;
}
.button:disabled {
  opacity: 0.1;
}
.button:active {
  opacity: 0.6;
}
.button-unchecked {
  opacity: 0.4;
}
#open-button {
    left: 0px;
    background: url(img/ic_photo_black_24px.svg) left top no-repeat;
}
#edit-mode-button {
    left: 40px;
}
.edit-rotate {
    background: url(img/ic_loop_black_24px.svg) left top no-repeat;
}
.edit-small-pt {
    background: url(img/4pt.svg) left top no-repeat;
}
.edit-medium-pt {
    background: url(img/7pt.svg) left top no-repeat;
}
.edit-large-pt {
    background: url(img/10pt.svg) left top no-repeat;
}
#log {
color: red;
padding: 0;
border: 0;
margin: 0;
}
</style>
<script>
var view;
var MirrorView = function() {
  this._MENU_HEIGHT = 40;
  this._lon = 90;
  this._lat = 0;
  this._ballSize = 0.2;
  this._scale = 1.0;
  this._mouseTracking = false;
  this._mouseDownPosX = 0;
  this._mouseDownPosY = 0;
  this._mouseDownLon = 0;
  this._mouseDownLat = 0;
  this._lastTouches = [];
  this._doubleTouchStartLat = 0;
  this._doubleTouchStartLon = 0;
  this._doubleTouchStartPos = 0;
  this._needsUpdate = true;
  this._lastUpdateTime = performance.now();
  this._step = 0;
  this._PI = 3.1415925358979;
  this._PI2 = 6.2831850718
};
MirrorView.prototype = {
  initialize: function(menuController) {
    this._menuController = menuController;
    this._mode = this._menuController.getEditMode();
    this._menuController.setView(this);

    this._canvas = document.createElement('canvas');
  	this._canvas.width  = window.innerWidth;
  	this._canvas.height = window.innerHeight - this._MENU_HEIGHT;
    var container = document.getElementById('container');
    window.addEventListener('resize', this._onWindowResize.bind(this), false);
    container.addEventListener('mousedown', this._onMouseDown.bind(this), false);
    container.addEventListener('mousemove', this._onMouseMove.bind(this), false);
    container.addEventListener('mouseup', this._onMouseUp.bind(this), false);
    container.addEventListener('mousewheel', this._onMouseWheel.bind(this), false);
    container.addEventListener('DOMMouseScroll', this._onMouseWheel.bind(this), false);
    container.addEventListener('touchstart', this._onTouchStart.bind(this), false);
    container.addEventListener('touchmove', this._onTouchMove.bind(this), false);
    container.addEventListener('touchend', this._onTouchEnd.bind(this), false);

    container.appendChild(this._canvas);
    this._gl = this._canvas.getContext('webgl') || this._canvas.getContext('experimental-webgl');
    this._gl.viewport(0, 0, this._gl.drawingBufferWidth, this._gl.drawingBufferHeight);
    var buffer = this._gl.createBuffer();
    this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffer);
    this._gl.bufferData(
      this._gl.ARRAY_BUFFER,
      new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0,  1.0]),
      this._gl.STATIC_DRAW);
    var vertexShader = this._gl.createShader(this._gl.VERTEX_SHADER);
    this._gl.shaderSource(vertexShader, document.getElementById("vertex-shader").text);
    this._gl.compileShader(vertexShader);

    var vertexShaderForFrameBuffer = this._gl.createShader(this._gl.VERTEX_SHADER);
    this._gl.shaderSource(vertexShaderForFrameBuffer, document.getElementById("vertex-shader-for-frame-buffer").text);
    this._gl.compileShader(vertexShaderForFrameBuffer);

    var fragmentShaderForFrameBuffer = this._gl.createShader(this._gl.FRAGMENT_SHADER);
    this._gl.shaderSource(fragmentShaderForFrameBuffer, document.getElementById("fragment-shader-for-frame-buffer").text);
    this._gl.compileShader(fragmentShaderForFrameBuffer);
    this._programForFrameBuffer = this._gl.createProgram();
    this._gl.attachShader(this._programForFrameBuffer, vertexShaderForFrameBuffer);
    this._gl.attachShader(this._programForFrameBuffer, fragmentShaderForFrameBuffer);
    this._gl.linkProgram(this._programForFrameBuffer);
    this._gl.useProgram(this._programForFrameBuffer);
    this._inputVector_loc = this._gl.getUniformLocation(this._programForFrameBuffer, 'inputVector');
    this._frameBufferSize_loc = this._gl.getUniformLocation(this._programForFrameBuffer, 'frameBufferSize');
    this._pointSize_loc = this._gl.getUniformLocation(this._programForFrameBuffer, 'pointSize');
    this._cosTableTexture_loc = this._gl.getUniformLocation(this._programForFrameBuffer, 'cosTableTexture');
    this._ySize_loc = this._gl.getUniformLocation(this._programForFrameBuffer, 'ySize');
    this._yBase_loc = this._gl.getUniformLocation(this._programForFrameBuffer, 'yBase');
    this._cosTableTexture = this._createCosTableTexture(4096);

    this._frameBuffer = this._createFrameBuffer(4096, 2048);

    var fragmentShader = this._gl.createShader(this._gl.FRAGMENT_SHADER);
    this._gl.shaderSource(fragmentShader, document.getElementById("fragment-shader").text);
    this._gl.compileShader(fragmentShader);

    this._program = this._gl.createProgram();
    this._gl.attachShader(this._program, vertexShader);
    this._gl.attachShader(this._program, fragmentShader);
    this._gl.linkProgram(this._program);
    this._gl.useProgram(this._program);

    var positionLocation = this._gl.getAttribLocation(this._program, "pos");
    this._gl.enableVertexAttribArray(positionLocation);
    this._gl.vertexAttribPointer(positionLocation, 2, this._gl.FLOAT, false, 0, 0);

    this._camLon_loc = this._gl.getUniformLocation(this._program, 'camLon');
    this._camLatSin_loc = this._gl.getUniformLocation(this._program, 'camLatSin');
    this._camLatCos_loc = this._gl.getUniformLocation(this._program, 'camLatCos');
    this._ballSize_loc = this._gl.getUniformLocation(this._program, 'ballSize');
    this._scale_loc = this._gl.getUniformLocation(this._program, 'scale');
    this._texture0_loc = this._gl.getUniformLocation(this._program, 'texture0');
    this._texture1_loc = this._gl.getUniformLocation(this._program, 'texture1');
    this._dispSize_loc = this._gl.getUniformLocation(this._program, 'dispSize');
    this._gl.uniform2f(this._dispSize_loc, this._canvas.width, this._canvas.height);


  	this._render();
  },
  loadImage: function(img) {
    if (this._texture) {
      this._gl.deleteTexture(this._texture);
    }
    this._texture = this._gl.createTexture();
    this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture);
    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, img);
    this._gl.generateMipmap(this._gl.TEXTURE_2D);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);
  	this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.REPEAT);
  	this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.REPEAT);
    this._gl.bindTexture(this._gl.TEXTURE_2D, null);
  },
  setEditMode: function(mode) {
    this._mode = mode;
  },
  _createCosTableTexture: function(width) {
    var canvas = document.createElement("canvas");
    document.body.appendChild(canvas);
    canvas.width = width;
    canvas.height = 1;
    var context = canvas.getContext("2d");
    var image = context.createImageData(width, 1);
    image[0] = image[1] = image[2] = image[3] = 255;
    for (var i = 1; i < width; i += 1) {
      var index = i * 4;
      var tmp0 = Math.cos(i*3.141592/2/width) * 256;
      var tmp1 = Math.floor(tmp0);
      image.data[index] = tmp1;
      tmp0 = (tmp0 - tmp1) * 256;
      tmp1 = Math.floor(tmp0);
      image.data[index + 1] = tmp1;
      tmp0 = (tmp0 - tmp1) * 256;
      tmp1 = Math.floor(tmp0);
      image.data[index + 2] = tmp1;
      image.data[index + 3] = 255;
    }
    context.putImageData(image, 0, 0);
    var texture = this._gl.createTexture();
    this._gl.bindTexture(this._gl.TEXTURE_2D, texture);
    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, canvas);
    this._gl.generateMipmap(this._gl.TEXTURE_2D);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.REPEAT);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.REPEAT);
    this._gl.bindTexture(this._gl.TEXTURE_2D, null);
    return texture;
  },
  _createFrameBuffer: function (width, height){
    var frameBuffer = this._gl.createFramebuffer();
    this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, frameBuffer);
    var renderBuffer = this._gl.createRenderbuffer();
    this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, renderBuffer);
    var texture = this._gl.createTexture();
    this._gl.bindTexture(this._gl.TEXTURE_2D, texture);
    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, width, height, 0, this._gl.RGBA, this._gl.UNSIGNED_BYTE, null);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);
    this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, texture, 0);
    this._gl.clearColor(0.0, 0.0, 0.0, 0.0);
    this._gl.clear(this._gl.COLOR_BUFFER_BIT);
    this._gl.bindTexture(this._gl.TEXTURE_2D, null);
    this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, null);
    this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
    return {f : frameBuffer, t : texture, width: width, height: height};
  },
  _drawPoint: function(x, y) {
    var poinrRotVec = this._getPointVector(x, y);
    if (this._mode == 'small-pt') {
      this._drawFramebufferPoint(poinrRotVec, 0.05);
    } else if (this._mode == 'medium-pt') {
      this._drawFramebufferPoint(poinrRotVec, 0.1);
    } else if (this._mode == 'large-pt') {
      this._drawFramebufferPoint(poinrRotVec, 0.4);
    }
  },
  _clearFrameBuffer: function() {
    this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._frameBuffer.f);
    this._gl.clearColor(0.0, 0.0, 0.0, 0.0);
    this._gl.clear(this._gl.COLOR_BUFFER_BIT);
    this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
  },
  _onMouseDown: function(event) {
    event.preventDefault();
    this._drawPoint(event.clientX, event.clientY - this._MENU_HEIGHT);
    this._mouseTracking = true;
    this._mouseDownPosX = event.clientX;
    this._mouseDownPosY = event.clientY - this._MENU_HEIGHT;
    this._mouseDownLon = this._lon;
    this._mouseDownLat = this._lat;
  },
  _onMouseMove: function(event) {
    if (this._mouseTracking && this._mode != 'rotate') {
      this._drawPoint(event.clientX, event.clientY - this._MENU_HEIGHT);
    }
    if (!this._mouseTracking || (this._mode != 'rotate'))
      return;
    this._lon = -(event.clientX - this._mouseDownPosX) * 0.2 + this._mouseDownLon;
    this._lat = -(event.clientY - this._MENU_HEIGHT - this._mouseDownPosY) * 0.2 + this._mouseDownLat;
    this._needsUpdate = true;
  },
  _onMouseUp: function(event) {
    this._clearFrameBuffer();
    this._mouseTracking = false;
  },
  _setScale: function(scale) {
    if (scale > 3)
      scale = 3;
    if (scale < 0.5)
      scale = 0.5;
    this._scale = scale;
  },
  _onMouseWheel: function(event) {
    if (event.wheelDeltaY) { // WebKit
      this._setScale(this._scale - event.wheelDeltaY * 0.01);
    } else if (event.wheelDelta) { // Opera / Explorer 9
      this._setScale(this._scale - event.wheelDelta * 0.01);
    } else if (event.detail) { // Firefox
      this._setScale(this._scale + event.detail * 0.2);
    }
    this._needsUpdate = true;
  },
  _updateLastTouches: function(touches) {
    this._lastTouches = [];
    for (var i = 0; i < touches.length; ++i) {
      this._lastTouches.push({
          clientX: touches[i].clientX,
          clientY: touches[i].clientY
        });
    }
  },
  _touchDist: function(touch1, touch2) {
    var xDiff = touch1.clientX - touch2.clientX;
    var yDiff = touch1.clientY - touch2.clientY;
    return Math.sqrt(xDiff * xDiff + yDiff * yDiff);
  },
  _touchCenter: function(touch1, touch2) {
    return {
      clientX: (touch1.clientX + touch2.clientX) / 2,
      clientY: (touch1.clientY + touch2.clientY) / 2
    };
  },
  _touchDiff: function(touch1, touch2) {
    return {
      clientX: touch1.clientX - touch2.clientX,
      clientY: touch1.clientY - touch2.clientY
    };
  },
  _onTouchStart: function(event) {
    event.preventDefault();
    if (this._lastTouches.length < 2 && event.touches.length == 2) {
      this._doubleTouchStartPos = this._touchCenter(event.touches[0], event.touches[1]);
      this._doubleTouchStartLon = this._lon;
      this._doubleTouchStartLat = this._lat;
    }
    if (this._mode != 'rotate') {
      if (this._lastTouches.length == 0 && event.touches.length == 1) {
        this._drawPoint(event.touches[0].clientX, event.touches[0].clientY - this._MENU_HEIGHT);
      } else {
        this._clearFrameBuffer();
      }
    }
    this._updateLastTouches(event.touches);
  },
  _onTouchMove: function(event) {
    if (this._lastTouches.length == 2 && event.touches.length == 2) {
      this._setScale(this._scale * this._touchDist(event.touches[0], event.touches[1]) / this._touchDist(this._lastTouches[0], this._lastTouches[1]));
      var diff = this._touchDiff(this._touchCenter(event.touches[0], event.touches[1]), this._doubleTouchStartPos);
      this._lon = -diff.clientX * 0.2 + this._doubleTouchStartLon;
      this._lat = -diff.clientY * 0.2 + this._doubleTouchStartLat;
      this._needsUpdate = true;
    }
    if (this._lastTouches.length == 1 && event.touches.length == 1) {
      if (this._mode == 'rotate') {
        var diff = this._touchDiff(event.touches[0], this._lastTouches[0]);
        this._lon = -diff.clientX * 0.2 + this._lon;
        this._lat = -diff.clientY * 0.2 + this._lat;
      } else {
        this._drawPoint(event.touches[0].clientX, event.touches[0].clientY - this._MENU_HEIGHT);
      }
      this._needsUpdate = true;
    }
    this._updateLastTouches(event.touches);
  },
  _onTouchEnd: function(event) {
    if (this._mode != 'rotate' && this._lastTouches.length == 1 && event.touches.length == 0) {
      this._clearFrameBuffer();
    }
    this._updateLastTouches(event.touches);
  },
  _onWindowResize: function() {
    this._canvas.width  = window.innerWidth;
    this._canvas.height = window.innerHeight - this._MENU_HEIGHT;
    this._gl.viewport(0, 0, this._gl.drawingBufferWidth, this._gl.drawingBufferHeight);
    this._gl.uniform2f(this._dispSize_loc, this._canvas.width, this._canvas.height);
    this._needsUpdate = true;
  },
  _drawFramebufferPoint: function(pointRotVector, size) {
    this._gl.enable(this._gl.BLEND);
    this._gl.blendFunc(this._gl.ONE, this._gl.ONE);
    this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._frameBuffer.f);
    this._gl.useProgram(this._programForFrameBuffer);
    this._gl.uniform3f(this._inputVector_loc, pointRotVector.x, pointRotVector.y, pointRotVector.z);
    this._gl.uniform2f(this._frameBufferSize_loc, this._frameBuffer.width, this._frameBuffer.height);
    this._gl.uniform1f(this._pointSize_loc, size);
    this._gl.activeTexture(this._gl.TEXTURE0);
    this._gl.bindTexture(this._gl.TEXTURE_2D, this._cosTableTexture);
    this._gl.uniform1i(this._cosTableTexture_loc, 0);
    this._gl.viewport(0, 0, this._frameBuffer.width, this._frameBuffer.height);
    var lat = Math.atan2(pointRotVector.y,this._length2({x: pointRotVector.x, y: pointRotVector.z}));
    this._gl.uniform1f(this._ySize_loc, Math.atan(size) * 2.0 / this._PI);
    this._gl.uniform1f(this._yBase_loc, lat  * 2.0 / this._PI);
    this._gl.drawArrays(this._gl.TRIANGLES, 0, 6);
    this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
    this._gl.disable(this._gl.BLEND);
  },
  _length2: function(vec) {
    return Math.sqrt(vec.x * vec.x + vec.y * vec.y);
  },
  _normalize2: function(vec) {
    if (vec.x == 0.0 && vec.y == 0.0)
      return vec;
    var len = this._length2(vec);
    return {x: vec.x / len, y: vec.y / len};
  },
  _length3: function(vec) {
    return Math.sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z);
  },
  _normalize3: function(vec) {
    if (vec.x == 0.0 && vec.y == 0.0 && vec.z == 0.0)
      return vec;
    var len = this._length3(vec);
    return {x: vec.x / len, y: vec.y / len, z: vec.z / len};
  },
  _rotateX: function(s, c, p) {
    return {x: p.x, y: c * p.y + s * p.z, z: s * p.y + c * p.z};
  },
  _rotateY: function(s, c, p) {
    return {x: c * p.x + s * p.z, y: p.y, z: s * p.x + c * p.z};
  },
  _rotateZ: function(s, c, p) {
    return {x: c * p.x + s * p.y, y: -s * p.x+ c * p.y, z: p.z};
  },
  _dot: function(v0, v1) {
    return v0.x * v1.x + v0.y * v1.y + v0.z * v1.z;
  },
  _reflect: function(i, n) {
    var d = this._dot(n, i);
    return {
      x: i.x - 2.0 * d * n.x,
      y: i.y - 2.0 * d * n.y,
      z: i.z - 2.0 * d * n.z};
  },
  _getPointVector: function(x, y) {
    var v = {x: (x - 0.5 * this._canvas.width) / (this._canvas.height * this._scale),
             y: (-y + 0.5 * this._canvas.height) / (this._canvas.height * this._scale)};
    var v2 = v.x * v.x + v.y * v.y;
    if (v2 > this._ballSize / (1.0 - this._ballSize)) {
      return {x: 0.0, y: 0.0, z: 0.0};
    }
    var camLatSin = Math.sin(this._lat * 3.141592 / 180.0);
    var camLatCos = Math.cos(this._lat * 3.141592 / 180.0);
    var camLon = this._lon * 3.141592 / 180.0;
    var v_size = Math.sqrt(v2);
    var tmp = Math.sqrt(this._ballSize + this._ballSize * v2 - v2);
    var normal_pos = this._normalize2(v);
    var normal_vector = this._normalize3({x: tmp + v2, y: v_size * (1.0 - tmp), z: 0.0});
    var normal_rotate_vector = this._rotateX(normal_pos.x, normal_pos.y, normal_vector);
    var input_vector = {x: -1.0, y: v.y, z: v.x};
    var reflect_vector = this._reflect(input_vector, normal_rotate_vector);
    var result = this._rotateZ(camLatSin, camLatCos, reflect_vector);
    var lon = Math.atan2(result.z, result.x) + camLon;
    var lat = Math.atan2(result.y, this._length3({x:result.x, y: 0.0, z:result.z}));
    var rot_vec = this._rotateY(Math.sin(lon), Math.cos(lon), this._rotateZ(Math.sin(lat), Math.cos(lat), {x: 1.0, y: 0.0, z: 0.0}));
    return rot_vec;
  },
  _render: function() {
    window.requestAnimationFrame(this._render.bind(this), this._canvas);
    ++this._step;
    if (!(this._step % 100)) {
      var now = performance.now();
      var logDiv = document.getElementById('log');
      logDiv.innerText = ('FPS: ' + 1000.0 * 100 / (now - this._lastUpdateTime));
      this._lastUpdateTime = now;
    }
    // if (!this._needsUpdate)
    //   return;
    // this._needsUpdate = false;

    this._gl.useProgram(this._program);
    this._lat = Math.max(-85, Math.min(85, this._lat));
    this._gl.uniform1f(this._camLon_loc, this._lon * 3.141592 / 180.0);
    this._gl.uniform1f(this._camLatSin_loc, Math.sin(this._lat * 3.141592 / 180.0));
    this._gl.uniform1f(this._camLatCos_loc, Math.cos(this._lat * 3.141592 / 180.0));
    this._gl.uniform1f(this._ballSize_loc, this._ballSize);
    this._gl.uniform1f(this._scale_loc, this._scale);

    this._gl.activeTexture(this._gl.TEXTURE0);
    if (this._texture) {
      this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture);
    } else {
      this._gl.bindTexture(this._gl.TEXTURE_2D, this._frameBuffer.t);
    }
    this._gl.uniform1i(this._texture0_loc, 0);

    this._gl.activeTexture(this._gl.TEXTURE1);
    this._gl.bindTexture(this._gl.TEXTURE_2D, this._frameBuffer.t);
    this._gl.uniform1i(this._texture1_loc, 1);

    this._gl.viewport(0, 0, this._gl.drawingBufferWidth, this._gl.drawingBufferHeight);
    this._gl.drawArrays(this._gl.TRIANGLES, 0, 6);
  }
};
window.addEventListener('load', init, false);

function isPowOfTwo(value) {
	return (value & (value - 1)) === 0 && value !== 0;
}
function nearestPowOfTwo ( value ) {
	return Math.pow(2, Math.round(Math.log( value ) / Math.LN2));
}


var MenuController = function() {
  this._edit_mode = 'medium-pt';
  this._EDIT_MODES = ['rotate', 'small-pt', 'medium-pt', 'large-pt'];
  this._EDIT_MODE_BUTTON_PREFIX = 'edit-';
  this._view = undefined;
};
MenuController.prototype = {
  initialize: function() {
    this._editButton = document.getElementById("edit-mode-button");
    this._editButton.addEventListener('click', this._onEditButtonClick.bind(this), false);
  },
  getEditMode: function(mode) {
    return this._edit_mode;
  },
  setView: function(view) {
    this._view = view;
  },
  _setEditMode: function(mode) {
    this._editButton.classList.toggle(this._EDIT_MODE_BUTTON_PREFIX + this._edit_mode);
    this._editButton.classList.toggle(this._EDIT_MODE_BUTTON_PREFIX + mode);
    this._edit_mode = mode;
    if (this._view) {
      this._view.setEditMode(mode);
    }
  },
  _getNestEditMode: function() {
    for (var i = 0; i < this._EDIT_MODES.length; ++i) {
      if (this._EDIT_MODES[i] == this._edit_mode) {
        return this._EDIT_MODES[(i + 1) % this._EDIT_MODES.length];
      }
    }
    return '';
  },
  _onEditButtonClick: function() {
    this._setEditMode(this._getNestEditMode());
  }
};
function init() {
  var menuController = new MenuController();
  menuController.initialize();
  view = new MirrorView();
  view.initialize(menuController);
  var img = new Image();
  img.addEventListener('load', (function() {
    if (isPowOfTwo(img.width) && isPowOfTwo(img.height)) {
      view.loadImage(img);
      return;
    }
    var c = document.createElement('canvas');
    c.width = nearestPowOfTwo(img.width);
    c.height = nearestPowOfTwo(img.height);
    c.getContext('2d').drawImage(img, 0, 0, c.width, c.height);
    view.loadImage(c);
  }).bind(this),false);
  img.crossOrigin='anonymous';
  img.src = 'https://lh3.googleusercontent.com/NeCTYzSXmHbNmhBsXXZZe6-ZNaYGYljJzq2fGF5tR65dz02YU_-C6al9TxjpMS_BlbbqlhBv6VCdpoGxQbP-FO2b=s5376'

}

</script>
<script id="vertex-shader" type="x-shader/x-vertex">// <![CDATA[
attribute vec2 pos;
void main() {
  gl_Position = vec4(pos, 0, 1);
}
// ]]></script>
<script id="vertex-shader-for-frame-buffer" type="x-shader/x-vertex">// <![CDATA[
attribute vec2 pos;
uniform float ySize;
uniform float yBase;
void main() {
  gl_Position = vec4(pos.x, pos.y*ySize+ yBase, 0, 1);
}
// ]]></script>
<script id="fragment-shader-for-frame-buffer" type="x-shader/x-fragment">// <![CDATA[
#define PI 3.1415925358979
#define PI2 6.2831850718
precision highp float;
uniform vec3 inputVector;
uniform vec2 frameBufferSize;
uniform float pointSize;

uniform sampler2D cosTableTexture;

vec3 rotateY(float s, float c, vec3 p){
  return vec3(c * p.x + s * p.z, p.y, s * p.x + c * p.z);
}
vec3 rotateX(float s, float c, vec3 p){
  return vec3(p.x, c * p.y + s * p.z, s * p.y + c * p.z);
}
vec3 rotateZ(float s, float c, vec3 p){
  return vec3(c * p.x + s * p.y, -s * p.x+ c * p.y, p.z);
}

float sinf(float x)
{
  x*=0.159155;
  x-=floor(x);
  float xx=x*x;
  float y=-6.87897;
  y=y*xx+33.7755;
  y=y*xx-72.5257;
  y=y*xx+80.5874;
  y=y*xx-41.2408;
  y=y*xx+6.28077;
  return x*y;
}

float cosf(float x)
{
  return sinf(x+1.5708);
}

float cosX(float x) {
  float signValue = 1.0;
  x = abs(x) / PI;
  x = x - floor(x / 2.0) * 2.0;
  if (x > 1.0) x = 2.0 - x;
  if (x > 0.5) {
    x = 1.0 - x;
    signValue = -1.0;
  }
  if (x == 0.0) {
    return 0.0;//signValue;
  }
  vec4 cosColor = texture2D(cosTableTexture, vec2(x/0.5, 0.0));
  float value = cosColor.r +
                cosColor.g / 256.0 +
                cosColor.b / 65536.0;
  return signValue * value;
}
float sinX(float x) {
  return cosX(x - PI / 2.0);
}
void main() {
  float lon = (gl_FragCoord.x / frameBufferSize.x) * PI2;
  float lat = -(gl_FragCoord.y / frameBufferSize.y - 0.5) * PI;
  vec3 pos_vec = rotateY(sinX(lon), cosX(lon), rotateZ(sinX(lat), cosX(lat), vec3(1.0, 0.0, 0.0)));
  if (dot(inputVector, pos_vec) > 0.0 &&
      distance(pos_vec, inputVector) < pointSize) {
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
  } else  {
    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
  }
}
// ]]></script>

<script id="fragment-shader" type="x-shader/x-fragment">// <![CDATA[
#define PI 3.1415925358979
#define PI2 6.2831850718
precision highp float;
uniform float camLon;
uniform float camLatSin;
uniform float camLatCos;
uniform float ballSize;
uniform float scale;

uniform sampler2D texture0;
uniform sampler2D texture1;
uniform vec2 dispSize;
/*
vec3 rotate(float angle, vec3 axis, vec3 p){
  float s = sin(angle);
  float c = cos(angle);
  vec3 a = normalize(axis);
  float r = 1.0 - c;
  return mat3(
      a.x * a.x * r + c,
      a.y * a.x * r + a.z * s,
      a.z * a.x * r - a.y * s,
      a.x * a.y * r - a.z * s,
      a.y * a.y * r + c,
      a.z * a.y * r + a.x * s,
      a.x * a.z * r + a.y * s,
      a.y * a.z * r - a.x * s,
      a.z * a.z * r + c) * p;
}*/
vec3 rotateX(float s, float c, vec3 p){
  return vec3(p.x, c * p.y + s * p.z, s * p.y + c * p.z);
}
vec3 rotateZ(float s, float c, vec3 p){
  return vec3(c * p.x + s * p.y, -s * p.x+ c * p.y, p.z);
}
void main() {
  vec2 v;
  v = vec2((gl_FragCoord.x - 0.5*dispSize.x) / (dispSize.y * scale), (gl_FragCoord.y - 0.5 * dispSize.y)/ (dispSize.y * scale));
  float v2;
  v2 = v.x * v.x + v.y * v.y;
  if (v2 > ballSize / (1.0 - ballSize)) {
    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    return;
  }
  float v_size = length(v);
  float tmp = sqrt(ballSize + ballSize * v2 - v2);
  vec2 normal_pos = normalize(v);
  vec3 normal_vector = normalize(vec3(tmp + v2, v_size * (1.0 - tmp), 0.0));
  vec3 normal_rotate_vector = rotateX(normal_pos.x, normal_pos.y, normal_vector);
  vec3 input_vector = vec3(-1.0, v.y, v.x);
  vec3 reflect_vector = reflect(input_vector, normal_rotate_vector);
  vec3 result = rotateZ(camLatSin, camLatCos, reflect_vector);
  float lon = atan(result.z, result.x);
  float lat = - atan(result.y, length(vec3(result.x, 0, result.z)));
  vec2 texPos = vec2((lon + camLon) / PI2, lat / PI + 0.5);
  vec4 overlayColor = texture2D(texture1, texPos);
  if (overlayColor.r == 1.0) {
    gl_FragColor = texture2D(texture0, texPos) * overlayColor;
  } else {
    gl_FragColor = texture2D(texture0, texPos);
  }
}
// ]]></script>
</head>
<div id="menu">
  <button id="open-button" class="button"></button>
  <button id="edit-mode-button" class="button edit-medium-pt"></button>
  <div id="log"></div>
</div>
<div id="container"></div>
</body>
</html>
